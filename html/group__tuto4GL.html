<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>gKit2 light: configurer un format de sommet, vertex array object</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">configurer un format de sommet, vertex array object</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto4GL_8cpp.html">tuto4GL.cpp</a></p>
<p>pour dessiner des triangles, il faut décrire les informations associées aux sommets, indiquer ou les trouver, leur organisation mémoire, et indiquer à quelles entrées du vertex shader elles sont associées.</p>
<p>le cas simple permettant de dessiner quelques triangles est présenté dans <a class="el" href="group__tuto3GL.html">afficher plusieurs triangles, modifier les paramètres uniform d'un shader program</a>.</p>
<h1><a class="anchor" id="vao"></a>
vertex array object</h1>
<p>c'est un objet openGL, appelé vertex array object, qui stocke la description du format de sommets.</p>
<p>la création des objets openGL utilise des fonctions de la forme glGenXXX( int n, GLuint *names ). cette famille de fonctions permet de créer plusieurs objets en même temps et renvoye un tableau d'identifiants des nouveaux objets. pour en créer un seul, on peut utiliser : </p><div class="fragment"><div class="line">GLuint vao;</div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
</div><!-- fragment --><p>il ne reste plus qu'à le sélectionner pour configurer le pipeline : </p><div class="fragment"><div class="line">glBindVertexArray(vao);</div>
</div><!-- fragment --><p>les informations des sommets, les attributs, sont stockées dans un ou plusieurs vertex buffers, qui ne sont que des tableaux alloués dans la mémoire de la carte graphique. cf <a class="el" href="group__tuto4GL.html#buffers">vertex buffers et index buffer</a> pour les créer et leur affecter des données.</p>
<p>le vertex array object stocke, pour chaque attribut déclaré par le vertex shader :</p><ul>
<li>le type de l'attribut, float, int, etc, paramètre type, GL_FLOAT, GL_INTEGER, etc.</li>
<li>le nombre de composants de l'attribut, 1 pour une valeur scalaire, ou 2, 3, 4 pour un vecteur, paramètre size,</li>
<li>l'identifiant du buffer dans lequel se trouve les valeurs, implicite, c'est le buffer sélectionné sur GL_ARRAY_BUFFER, cf <a class="el" href="group__tuto4GL.html#buffers">vertex buffers et index buffer</a>,</li>
<li>la position de la première valeur dans le buffer, paramètre offset,</li>
<li>la distance entre chaque valeur dans le buffer, paramètre stride.</li>
</ul>
<p>l'indexation des sommets (l'index buffer) peut aussi être associé à un vertex array objet.</p>
<p>la configuration se fait en plusieurs étapes :</p><ul>
<li>récupérer l'identifiant de l'attribut dans le vertex shader, cf glGetAttribLocation( ),</li>
<li>sélectionner le vertex buffer sur GL_ARRAY_BUFFER,</li>
<li>apeller glVertexAttribPointer( ),</li>
<li>utiliser l'attribut, cf glEnableVertexAttribArray( )</li>
</ul>
<p>exemple : le cas classique, le vertex buffer, identifiant buffer, contient les positions des sommets. le vertex shader déclare : <code>in <a class="el" href="structvec3.html" title="vecteur generique, utilitaire. ">vec3</a> position;</code> </p><div class="fragment"><div class="line"><span class="comment">// selectionner le vertex array object a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindVertexArray(vao);</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// recuperer l&#39;identifiant de l&#39;attribut </span></div>
<div class="line">GLint attribute= glGetAttribLocation(program, <span class="stringliteral">&quot;position&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(attribute &lt; 0)</div>
<div class="line">    <span class="comment">// probleme, l&#39;attribut n&#39;existe pas... erreur de compilation / link du program ?</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// selectionner le vertex buffer contenant les donnees</span></div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// configurer l&#39;attribut</span></div>
<div class="line">glVertexAttribPointer(attribute, </div>
<div class="line">    3, GL_FLOAT,    <span class="comment">// size et type, position est un vec3 dans le vertex shader</span></div>
<div class="line">    GL_FALSE,       <span class="comment">// pas de normalisation des valeurs</span></div>
<div class="line">    0,              <span class="comment">// stride 0, les valeurs sont les unes a la suite des autres</span></div>
<div class="line">    0               <span class="comment">// offset 0, les valeurs sont au debut du buffer</span></div>
<div class="line">);</div>
<div class="line">glEnableVertexAttribArray(attribute);</div>
</div><!-- fragment --><p>exemple : si le maillage est décrit par des sommets partagés, l'index buffer stocke des triplets d'indices pour décrire chaque triangle. Les opérations sont les mêmes que pour un vertex buffer, par contre, il faut sélectionner le buffer sur GL_ELEMENT_ARRAY_BUFFER :</p>
<div class="fragment"><div class="line"><span class="comment">// selectionner le vertex array object a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindVertexArray(vao);</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// selectionner l&#39;index buffer et configurer le vao</span></div>
<div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, index_buffer);</div>
</div><!-- fragment --><p><b>remarque : nettoyage / revenir à l'état par défaut</b></p>
<p>il y a en général un index buffer et un vertex buffer sélectionné ainsi que le vao. quelle est la bonne manière de les désélectionner :</p><ul>
<li>réponse A : <div class="fragment"><div class="line">glBindBuffer(GL_ARRAY_BUFFER, 0);</div>
<div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</div>
<div class="line">glBindVertexArray(0);</div>
</div><!-- fragment --></li>
<li>réponse B : <div class="fragment"><div class="line">glBindVertexArray(0);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, 0);</div>
<div class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);</div>
</div><!-- fragment --></li>
</ul>
<p><em>rappel :</em> certains paramètres sont implicites... le vao en cours de configuration, par exemple</p>
<h2>et avec plusieurs attributs ?</h2>
<p>il faut décrire chaque attribut déclaré.</p>
<p>exemple : position_buffer contient les positions, normal_buffer contient les normales des sommets, et les attributs sont déclarés comme : <code>in <a class="el" href="structvec3.html" title="vecteur generique, utilitaire. ">vec3</a> position; in <a class="el" href="structvec3.html" title="vecteur generique, utilitaire. ">vec3</a> normal;</code> dans le vertex shader : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le vertex array object a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindVertexArray(vao);</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// recuperer l&#39;attribut</span></div>
<div class="line">GLint position_attribute= glGetAttribLocation(program, <span class="stringliteral">&quot;position&quot;</span>);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, position_buffer);</div>
<div class="line">glVertexAttribPointer(position_attribute, 3, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">glEnableVertexAttribArray(position_attribute);</div>
<div class="line"></div>
<div class="line"><span class="comment">// recuperer l&#39;attribut</span></div>
<div class="line">GLint normal_attribute= glGetAttribLocation(program, <span class="stringliteral">&quot;normal&quot;</span>);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, normal_buffer);</div>
<div class="line">glVertexAttribPointer(normal_attribute, 3, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">glEnableVertexAttribArray(normal_attribute);</div>
</div><!-- fragment --><p>exemple complet : <a class="el" href="tuto4GL__normals_8cpp.html">tuto4GL_normals.cpp</a></p>
<p>pour récupérer la liste des attributs déclarés par le vertex shader et vérifier qu'ils sont bien associés à un buffer, cf <a class="el" href="group__shader__reflect.html">récupérer les uniforms et les attributs utilisés par un shader program</a></p>
<h2>et si un attribut n'existe plus dans le vertex shader ?? ( glGetAttribLocation( ) &lt; 0 )</h2>
<p>le compilateur et le linker des shaders sont capables de déterminer qu'un attribut n'est pas nécessaire pour exécuter un shader. par exemple :</p>
<div class="fragment"><div class="line"><span class="comment">// vertex shader</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> normal;</div>
<div class="line"></div>
<div class="line">uniform mat4 mvpMatrix;</div>
<div class="line">uniform mat4 mvMatrix;</div>
<div class="line"></div>
<div class="line"><span class="comment">// normal est un attribut du vertex shader, il n&#39;est pas disponible dans le fragment shader, donc :</span></div>
<div class="line">out <a class="code" href="structvec3.html">vec3</a> view_normal;</div>
<div class="line"><span class="comment">// il faut declarer un varying, un resultat du vertex shader</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    gl_Position= mvpMatrix * <a class="code" href="structvec4.html">vec4</a>(position, 1);</div>
<div class="line">    view_normal= mat3(mvMatrix) * normal;   <span class="comment">// uniquement une rotation, mat3 suffit </span></div>
<div class="line">    </div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// recupere la normale calculee par le vertex shader, meme type, meme nom, mais in au lieu de out</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> view_normal;</div>
<div class="line"><span class="comment">// rappel: interpolation en fonction de la position du fragment dans le triangle</span></div>
<div class="line"></div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    fragment_color= <a class="code" href="structvec4.html">vec4</a>(color, 1);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>la couleur des fragments est constante, elle ne depend pas de la normale calculée par le vertex shader, et glGetAttibLocation( ... "normal" ) renvoie -1 dans ce cas, alors que l'attribut normal est correctement déclaré.</p>
<p>si le fragment shader est modifié pour utiliser la normale :</p>
<div class="fragment"><div class="line">in <a class="code" href="structvec3.html">vec3</a> view_normal;</div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> fragment_color;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main( )</div>
<div class="line">{</div>
<div class="line">    fragment_color= <a class="code" href="structvec4.html">vec4</a>(color * <a class="code" href="group__math.html#gae536ea1a67e0b896ceebfeff08b18d3d">normalize</a>(view_normal).z, 1);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>glGetAttribLocation( ... "normal" ) renverra bien un identifiant valide dans ce cas. il faut prévoir les 2 cas dans le programme, il y a 2 manières de le gérer,</p><ul>
<li>soit faire le test, et ne configurer le vertex array object que si l'attribut est utilisé / nécessaire <div class="fragment"><div class="line"><span class="comment">// recuperer l&#39;attribut</span></div>
<div class="line">GLint attribute= glGetAttribLocation(program, <span class="stringliteral">&quot;normal&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(attribute &gt;= 0)</div>
<div class="line">{</div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line">    glVertexAttribPointer(attribute, 3, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">    glEnableVertexAttribArray(attribute);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>soit ne pas faire le test et toujours configurer le vertex array, le shader n'utilisera que ce qui est nécessaire et/ou openGL ignore les attributs non valides... <div class="fragment"><div class="line"><span class="comment">// recuperer l&#39;attribut</span></div>
<div class="line">GLint attribute= glGetAttribLocation(program, <span class="stringliteral">&quot;normal&quot;</span>);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line">glVertexAttribPointer(attribute, 3, GL_FLOAT, GL_FALSE, 0, 0);</div>
<div class="line">glEnableVertexAttribArray(attribute);</div>
</div><!-- fragment --></li>
</ul>
<p><em>remarque :</em> les attributs peuvent être numérotés directement par le vertex shader, et dans ce cas l'utilisation de glGetAttribLocation( ) n'est pas nécessaire, cf la section <a class="el" href="group__tuto4GL.html#location">et sans utiliser glGetAttribLocation( ) ?</a>.</p>
<h2>et si les attributs sont dans le même vertex buffer ?</h2>
<p>les paramètres stride et offset de glVertexAttribPointer( ) permettent d'organiser les données assez librement :</p><ul>
<li>offset donne la position de la première valeur dans le buffer (en octets),</li>
<li>stride donne la distance à la laquelle se trouve la valeur suivante (en octets), ce qui permet d'itérer sur tous les attributs sans problèmes.</li>
</ul>
<p><em>remarque :</em> stride = 0 est interprété comme l'organisation par défaut, les valeurs se suivent, c'est équivalent à stride= sizeof()</p>
<p>exemple : position et normale dans le même buffer, toutes les positions, puis toutes les normales : <code>PPPPPPPPNNNNNNNN</code> </p><div class="fragment"><div class="line">offset(position)= 0;</div>
<div class="line">stride(position)= 0;        <span class="comment">// par definition stride(position) == sizeof(vec3)</span></div>
<div class="line"></div>
<div class="line">offset(normal)= <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>) * positions.size();</div>
<div class="line">stride(normal)= 0;          <span class="comment">// ou stride(normal) == sizeof(vec3)</span></div>
</div><!-- fragment --><p>exemple : alterner les donnees, position + normale sommet 0, position + normale sommet 1, etc : <code>PNPNPNPNPNPNPN</code> </p><div class="fragment"><div class="line">offset(position)= 0;</div>
<div class="line">stride(position)= <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>) + <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>);  <span class="comment">// la prochaine position se trouve apres la normale du sommet</span></div>
<div class="line"></div>
<div class="line">offset(normal)= <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>);                   <span class="comment">// la premiere normale se trouve apres la premiere position</span></div>
<div class="line">stride(normal)= <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>) + <span class="keyword">sizeof</span>(<a class="code" href="structvec3.html">vec3</a>);</div>
</div><!-- fragment --><p>cf <a class="el" href="group__tuto4GL.html#single_buffer">exemple : utiliser un seul buffer pour stocker les attributs et configurer le vao</a> pour un exemple complet de création.</p>
<h1><a class="anchor" id="buffers"></a>
vertex buffers et index buffer</h1>
<p>les buffers sont des tableaux alloués dans la mémoire de la carte graphique, il faut leur donner une dimension (en octets) et transférer des données, cf glBufferData( ).</p>
<p>on peut également modifier le contenu d'un buffer à n'importe quel moment, cf glBufferSubData( ). en fonction de la fréquence de modifications, il faut choisir l'option correspondante lors de la création, cf le paramètre usage de glBufferData( ). l'option par défaut est GL_STATIC_DRAW qui indique que le buffer est utilisé par glDraw( ) et que son contenu ne devrait pas changer.</p>
<p>mais bien sur, il faut commencer par créer l'objet openGL, cf glGenBuffers( ) : </p><div class="fragment"><div class="line">GLuint buffer;</div>
<div class="line">glGenBuffers(1, &amp;buffer);</div>
</div><!-- fragment --><p>pour pouvoir manipuler un buffer, il faut le sélectionner, comme les autres objets openGL, cf glBindBuffer( ) :</p><ul>
<li>les vertex buffers sont sélectionnés sur GL_ARRAY_BUFFER,</li>
<li>les index buffers, sur GL_ELEMENT_ARRAY_BUFFER.</li>
</ul>
<p>exemple : créer un vertex buffer pour stocker les positions d'un mesh, cf <a class="el" href="classMesh.html#a7f36bd03c3ceda71474630b076bf08e7" title="renvoie l&#39;adresse de la position du premier sommet. permet de construire les vertex buffers openGL...">Mesh::vertex_buffer()</a> et <a class="el" href="classMesh.html#a0af0c5749a14a066defb02aa65cb62be" title="renvoie la longueur (en octets) du vertex buffer. ">Mesh::vertex_buffer_size()</a>, pour récupérer les infos nécessaires : </p><div class="fragment"><div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh= ... ;</div>
<div class="line"></div>
<div class="line"><span class="comment">// cree un nouveau buffer</span></div>
<div class="line">GLuint buffer;</div>
<div class="line">glGenBuffers(1, &amp;buffer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// selectionner le buffer comme un vertex buffer</span></div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// dimensionner et intialiser le buffer selectionne sur array_buffer</span></div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, mesh.<a class="code" href="classMesh.html#a0af0c5749a14a066defb02aa65cb62be">vertex_buffer_size</a>(), mesh.<a class="code" href="classMesh.html#a7f36bd03c3ceda71474630b076bf08e7">vertex_buffer</a>(), GL_STATIC_DRAW);</div>
</div><!-- fragment --><p>exemple : créer un vertex buffer, le dimensionner et changer son contenu </p><div class="fragment"><div class="line">GLuint buffer;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> buffer_size;</div>
<div class="line"><span class="keywordtype">int</span> init( )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classMesh.html">Mesh</a> mesh= ... ;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// cree un nouveau buffer</span></div>
<div class="line">    glGenBuffers(1, &amp;buffer);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// selectionner le buffer comme un vertex buffer</span></div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// dimensionner le buffer selectionne sur array_buffer</span></div>
<div class="line">    buffer_size= mesh.<a class="code" href="classMesh.html#a0af0c5749a14a066defb02aa65cb62be">vertex_buffer_size</a>();</div>
<div class="line">    glBufferData(GL_ARRAY_BUFFER, buffer_size, <span class="comment">/* data */</span> NULL, GL_STATIC_DRAW);</div>
<div class="line">    <span class="comment">// pas de donnees pour initialiser le contenu du buffer...</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="group__objet3D.html#ga749ef04b579edc715d094c57395f7492">draw</a>( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// calculer les valeurs a copier dans le buffer</span></div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> *data= { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// transferer les nouvelles valeurs</span></div>
<div class="line">    <span class="comment">// selectionner le buffer</span></div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, buffer)</div>
<div class="line">    glBufferSubData(GL_ARRAY_BUFFER, <span class="comment">/* offset */</span> 0, <span class="comment">/* length */</span> buffer_size, data);</div>
<div class="line">    <span class="comment">// offset et length permettent de ne modifier qu&#39;une partie du buffer</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="single_buffer"></a>
exemple : utiliser un seul buffer pour stocker les attributs et configurer le vao</h1>
<p>le buffer est remplit avec toutes les positions, suivies de toutes les texcoords, et enfin toutes les normales : </p><div class="fragment"><div class="line"><a class="code" href="classMesh.html">Mesh</a> mesh= <a class="code" href="group__objet3D.html#ga9982954fa508a4c2c9a26e06e09b7352">read_mesh</a>( ... );</div>
<div class="line">GLuint vao;</div>
<div class="line">GLuint buffer;</div>
<div class="line"></div>
<div class="line"><span class="comment">// creer et selectionner le vao</span></div>
<div class="line">glGenVertexArrays(1, &amp;vao);</div>
<div class="line">glBindVertexArray(vao);</div>
<div class="line"></div>
<div class="line"><span class="comment">// creer, initialiser le buffer : positions + normals + texcoords du mesh</span></div>
<div class="line">glGenBuffers(1, &amp;buffer);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</div>
<div class="line"></div>
<div class="line"><span class="comment">// taille totale du buffer</span></div>
<div class="line"><span class="keywordtype">size_t</span> size= mesh.<a class="code" href="classMesh.html#a0af0c5749a14a066defb02aa65cb62be">vertex_buffer_size</a>() + mesh.<a class="code" href="classMesh.html#ab01215355fd5435e101d2f10f9b7c7bd">texcoord_buffer_size</a>() + mesh.<a class="code" href="classMesh.html#a61b1105856b4f1ac7074085f8ae2461c">normal_buffer_size</a>();</div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, size, <span class="keyword">nullptr</span>, GL_STATIC_DRAW);</div>
<div class="line"></div>
<div class="line"><span class="comment">// transfere les positions des sommets</span></div>
<div class="line"><span class="keywordtype">size_t</span> offset= 0;</div>
<div class="line">size= mesh.<a class="code" href="classMesh.html#a0af0c5749a14a066defb02aa65cb62be">vertex_buffer_size</a>();</div>
<div class="line">glBufferSubData(GL_ARRAY_BUFFER, offset, size, mesh.<a class="code" href="classMesh.html#a7f36bd03c3ceda71474630b076bf08e7">vertex_buffer</a>());</div>
<div class="line"><span class="comment">// et configure l&#39;attribut 0, vec3 position</span></div>
<div class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, <span class="comment">/* stride */</span> 0, (<span class="keyword">const</span> GLvoid *) offset);</div>
<div class="line">glEnableVertexAttribArray(0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// transfere les texcoords des sommets</span></div>
<div class="line">offset= offset + size;</div>
<div class="line">size= mesh.<a class="code" href="classMesh.html#ab01215355fd5435e101d2f10f9b7c7bd">texcoord_buffer_size</a>();</div>
<div class="line">glBufferSubData(GL_ARRAY_BUFFER, offset, size, mesh.<a class="code" href="classMesh.html#af4c626726a0ca667ca6d320e98021539">texcoord_buffer</a>());</div>
<div class="line"><span class="comment">// et configure l&#39;attribut 1, vec2 texcoord</span></div>
<div class="line">glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, <span class="comment">/* stride */</span> 0, (<span class="keyword">const</span> GLvoid *) offset);</div>
<div class="line">glEnableVertexAttribArray(1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// transfere les normales des sommets</span></div>
<div class="line">offset= offset + size;</div>
<div class="line">size= mesh.<a class="code" href="classMesh.html#a61b1105856b4f1ac7074085f8ae2461c">normal_buffer_size</a>();</div>
<div class="line">glBufferSubData(GL_ARRAY_BUFFER, offset, size, mesh.<a class="code" href="classMesh.html#abe8f32346c34d4da72295dcf370110f0">normal_buffer</a>());</div>
<div class="line"><span class="comment">// et configure l&#39;attribut 2, vec3 normal</span></div>
<div class="line">glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, <span class="comment">/* stride */</span> 0, (<span class="keyword">const</span> GLvoid *) offset);</div>
<div class="line">glEnableVertexAttribArray(2);</div>
</div><!-- fragment --><h1><a class="anchor" id="location"></a>
et sans utiliser glGetAttribLocation( ) ?</h1>
<p>il suffit de donner l'identifiant directement dans le source du vertex shader avec <code>layout(location= id) in <a class="el" href="structvec3.html" title="vecteur generique, utilitaire. ">vec3</a> attribute;</code>: </p><div class="fragment"><div class="line">layout(location= 0) in <a class="code" href="structvec3.html">vec3</a> position;</div>
</div><!-- fragment --><p>l'exemple de création de buffer / configuration de vao précédent suppose que position est l'attribut 0, texcoord est l'attribut 1 et normal est l'attribut 2, ce qui se déclare comme ça : </p><div class="fragment"><div class="line">layout(location= 0) in <a class="code" href="structvec3.html">vec3</a> position;</div>
<div class="line">layout(location= 1) in <a class="code" href="structvec2.html">vec2</a> texcoord;</div>
<div class="line">layout(location= 2) in <a class="code" href="structvec3.html">vec3</a> normal;</div>
</div><!-- fragment --><p>et la création des buffers / configuration du vao peut etre simplifiée, puisque l'on connait les identifiants des attributs. cf l'exemple précédent <a class="el" href="group__tuto4GL.html#single_buffer">exemple : utiliser un seul buffer pour stocker les attributs et configurer le vao</a>. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 27 2017 09:25:26 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
