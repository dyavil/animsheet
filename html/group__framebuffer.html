<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>gKit2 light: rendu multi-passes : shadow maps, post process</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gKit2 light
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">rendu multi-passes : shadow maps, post process</div>  </div>
</div><!--header-->
<div class="contents">
<p>cf <a class="el" href="tuto__framebuffer_8cpp.html">tuto_framebuffer.cpp</a></p>
<p>Dans plusieurs cas, il est nécessaire de "récupérer" le résultat d'un rendu pour le modifier avant l'affichage final. par exemple, on peut vouloir filtrer l'image brute avant de l'afficher. ou ajuster les couleurs pour produire une ambiance chaude ou froide, ajouter un grain dans l'image, etc. il faut donc pouvoir recupérer le color buffer et éventuellement le zbuffer qui sont habituellement affichés directement dans la fenêtre de l'application.</p>
<p>De manière générale, certaines méthodes de rendu sont trop complexes pour être réalisées avec une seule exécution du pipeline graphique. une solution est de découper le rendu complet en plusieurs étapes, chaque étape utilisant l'image produite par l'étape précédente, jusqu'à obtenir le résultat final que l'on peut afficher.</p>
<p>Ce sont des objets openGL, des framebuffer objects, notés FBO, qui permettent de configurer le pipeline pour stocker les résultats des fragment shaders dans des textures crées par l'application, au lieu de les afficher directement.</p>
<p>Leur utilisation est semblable aux autres objets "complexes" d'openGL (comme les vertex array objects, VAO) :</p><ul>
<li>création, cf glGenFramebuffers( ),</li>
<li>sélection, cf glBindFramebuffer( ),</li>
<li>sélection des textures sur les sorties du framebuffer, cf glFramebufferTexture( ),</li>
<li>association des sorties du fragment shader aux sorties du framebuffer, cf glDrawBuffers( ).</li>
</ul>
<p>mais bien sur, il faut commencer par créer un objet framebuffer et le sélectionner pour le configurer : </p><div class="fragment"><div class="line">GLuint framebuffer;</div>
<div class="line">glGenFramebuffers(1, &amp;framebuffer);</div>
<div class="line"></div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
</div><!-- fragment --><p>ensuite, il n'y a plus qu'à indiquer quelles textures vont stocker les résultats exportés par le fragment shader et le pipeline. Les sorties d'un fragment shader sont une ou plusieurs couleurs, ainsi que la profondeur du fragment. ces différentes sorties sont identifiées par :</p><ul>
<li>GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 ... GL_COLOR_ATTACHMENT7, pour les color buffers, les couleurs,</li>
<li>GL_DEPTH_ATTACHMENT, pour le zbuffer, la profondeur du fragment.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"></div>
<div class="line">GLuint color_texture;</div>
<div class="line"><span class="comment">// creer la texture couleur aux dimensions de la fenetre</span></div>
<div class="line">{ ... }</div>
<div class="line"></div>
<div class="line"><span class="comment">// associer la texture à une sortie du framebuffer</span></div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
</div><!-- fragment --><p>reste une dernière option dans la configuration, récupérer l'identifiant d'une sortie déclarée dans le fragment shader et l'associer à une sortie du framebuffer, cf glDrawBuffers( ). il faut lui transmettre un tableau d'identifiants GL_NONE, GL_COLOR_ATTACHMENTxx indexé par l'identifiant de la sortie du fragment shader.</p>
<p>si le fragment shader ne déclare qu'une seule sortie, son identifiant est 0 par convention, il suffit de remplir un tableau contenant la sortie configurée dans le framebuffer à l'indice 0 : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"></div>
<div class="line">GLenum buffers[]= { GL_COLOR_ATTACHMENT0 };</div>
<div class="line">glDrawBuffers(1, buffers);</div>
</div><!-- fragment --><p><b>remarque :</b> on peut configurer n'importe quel attachment dans le fbo : </p><div class="fragment"><div class="line"><span class="comment">// selectionner le framebuffer a configurer, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT4, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"></div>
<div class="line">GLenum buffers[]= { GL_COLOR_ATTACHMENT4 };</div>
<div class="line">glDrawBuffers(1, buffers);</div>
</div><!-- fragment --><p>pour "décoder" la configuration de fbo, le plus simple est de partir de la sortie dans le fragment shader : son identifiant est 0, donc la valeur sera écrite dans l'attachment d'indice 0 passé à glDrawBuffers(). et la texture stockant la valeur est celle sélectionnée par glFramebufferTexture( ) sur l'attachment correspondant.</p>
<h2>dessiner dans un framebuffer</h2>
<p>il suffit de sélectionner le framebuffer sur GL_DRAW_FRAMEBUFFER avec glBindFramebuffer( ) avant de dessiner quelquechose : </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line"></div>
<div class="line">glBindVertexArray( ... );</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"></div>
<div class="line">glDrawArrays(GL_TRIANGLES, ... );</div>
</div><!-- fragment --><p><b>attention :</b> glDraw() utilise <em>implicitement</em> plusieurs paramètres : les dimensions du viewport, par exemple (et le framebuffer sélectionné, bien sur). il faudra donc penser à utiliser <code>glViewport()</code> si les dimensions des textures ne sont pas les memes que celles de la fenetre de l'application.</p>
<p><em>remarque :</em> effacer le framebuffer avant de dessiner : </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
</div><!-- fragment --><p><code>Clear( COLOR_BUFFER_BIT ... )</code> copie la couleur par défaut dans toutes les textures associées aux <code>COLOR_ATTACHMENTxx</code> et <code>Clear( DEPTH_BUFFER_BIT ... )</code> copie la profondeur par défaut dans la texture associée à <code>DEPTH_ATTACHMENT</code>.</p>
<p><code>Clear( )</code> utilise <em>implicitement</em> les dimensions fournies par glViewport( ), donc il faut penser à configurer le viewport avant...</p>
<p>si l'on souhaite utiliser des valeurs / couleurs différentes selon le buffer, il faut utiliser glClearBuffer(). par exemple pour "effacer", le buffer 0 : </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color_texture, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"></div>
<div class="line">GLenum buffers[]= { GL_COLOR_ATTACHMENT0 };</div>
<div class="line">glDrawBuffers(1, buffers);</div>
<div class="line"></div>
<div class="line"><a class="code" href="structColor.html">Color</a> color(1, 0, 0);</div>
<div class="line">glClearBufferfv(GL_COLOR, <span class="comment">/* draw buffer */</span> GL_DRAW_BUFFER0, <span class="comment">/* value */</span> &amp;color.x);</div>
</div><!-- fragment --><p><code>DRAW_BUFFER0</code> est l'indice dans le tableau <code>buffers</code>, <code>buffers[0]</code> contient <code>COLOR_ATTACHMENT0</code>, et c'est la texture <code>color_texture</code> qui sera finalement modifiée / effacée.</p>
<h2>et glViewport( ) ?</h2>
<p>il faut aussi configurer le pipeline en fonction des dimensions des textures associées au framebuffer. </p><div class="fragment"><div class="line">GLuint framebuffer= { ... };</div>
<div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">glViewport(0, 0, framebuffer_width, framebuffer_height);</div>
<div class="line"></div>
<div class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</div>
</div><!-- fragment --><p>glClear( ) et glDraw( ) utilisent <em>implicitement</em> les dimensions fournies par glViewport( ), donc il faut configurer viewport avant clear et draw...</p>
<h2>dessiner dans la fenetre ? (framebuffer par défaut)</h2>
<p>il suffit de sélectionner le framebuffer 0 avant de dessiner : </p><div class="fragment"><div class="line">glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">glViewport(0, 0, <a class="code" href="group__application.html#gae3a7daacf8fe05cc4e57d8557ec4e475">window_width</a>(), <a class="code" href="group__application.html#ga4d0b205b70f38973c8c5395f31f77baf">window_height</a>());</div>
<div class="line">glClear(GL_COLOR_BUFFER_BIt | GL_DEPTH_BUFFER_BIT);</div>
<div class="line"></div>
<div class="line">glBindVertexArray( ... );</div>
<div class="line">glUseProgram( ... );</div>
<div class="line">glUniform( ... );</div>
<div class="line"></div>
<div class="line">glDrawArrays(GL_TRIANGLES, ... );</div>
</div><!-- fragment --><h2>récupérer l'identifiant d'une sortie du fragment shader</h2>
<p>c'est glGetFragDataLocation( ) qui renvoie l'identifiant du varying déclaré par le fragment shader : </p><div class="fragment"><div class="line">GLuint program= ... ;</div>
<div class="line"></div>
<div class="line">GLint location= glGetFragDataLocation(program, <span class="stringliteral">&quot;fragment_color&quot;</span>);</div>
</div><!-- fragment --><p>et on peut utiliser cette valeur pour configurer le framebuffer, cf glDrawBuffers() : </p><div class="fragment"><div class="line">GLuint program= ... ;</div>
<div class="line">GLuint framebuffer = .... ;</div>
<div class="line">GLenum buffers[8]= { GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE, GL_NONE };</div>
<div class="line">GLint location= glGetFragDataLocation(program, <span class="stringliteral">&quot;fragment_color&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(location &gt;= 0)</div>
<div class="line">    buffers[location]= GL_COLOR_ATTCHMENT0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// selectionner le fbo, si necessaire</span></div>
<div class="line"><span class="comment">// glBindFamebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</span></div>
<div class="line"></div>
<div class="line">glDrawBuffers(8, buffers); </div>
</div><!-- fragment --><h1>créer une texture de profondeur / zbuffer</h1>
<p>Jusqu'à présent cf <a class="el" href="group__tuto5GL.html">textures, samplers et pipeline</a>, les textures peuvent stocker des couleurs (dont les valeurs sont comprises entre 0 et 1) sur plusieurs canaux r, g, b (et alpha, éventuellement). il est aussi possible de créer des textures pour stocker une valeur de profondeur par texel avec le format <code>GL_DEPTH_COMPONENT</code> (un entier normalise entre 0 et 1) :</p>
<div class="fragment"><div class="line">GLuint zubffer;</div>
<div class="line">glGenTextures(1, &amp;zbuffer);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, zbuffer);</div>
<div class="line"></div>
<div class="line">glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT, width, height, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>ou <code>GL_DEPTH_COMPONENT32F</code> (un réel 32bits, un <code>float</code> classique) : </p><div class="fragment"><div class="line">GLuint zubffer;</div>
<div class="line">glGenTextures(1, &amp;zbuffer);</div>
<div class="line">glBindTexture(GL_TEXTURE_2D, zbuffer);</div>
<div class="line"></div>
<div class="line">glTexImage2D(GL_TEXTURE_2D, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT32F, width, height, 0,</div>
<div class="line">    GL_DEPTH_COMPONENT32F, GL_FLOAT, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><h1>utiliser une texture attachée à un framebuffer</h1>
<p>Dessiner dans un framebuffer, et dans les textures associées, ne modifie que le niveau de mipmap attaché au framebuffer, cf glFramebufferTexture( ... level), le mipmap 0, le plus souvent. Mais lorsque l'on utilise cette texture dans l'étape suivante, ses autres mipmaps n'ont pas changés de valeurs. Et selon le mode filtrage utilsé par le shader pour accéder à la texture, les résultats peuvent être surprenants...</p>
<p>par exemple, les paramètres par défaut de filtrage, cf <code>LINEAR_MIPMAP_LINEAR</code>, interpolent 2 mipmaps et 4 texels par mipmap, mais seul le mipmap 0 a ete modifie, et le résultat sera faux.</p>
<p>il y a 2 solutions, soit utiliser un filtrage <code>NEAREST_MIPMAP_LINEAR</code> et <code>MAX_LEVEL</code> = 0 qui n'utilise que le mipmap 0, soit recalculer tous les mipmaps de la texture, cf glGenerateMipmap( ).</p>
<div class="fragment"><div class="line">GLuint color= { ... };</div>
<div class="line">GLuint framebuffer= { ... };</div>
<div class="line"></div>
<div class="line">init( )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// configuration framebuffer / texture</span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">    glFramebufferTexture(GL_DRAW_FRAMEBUFFER, <span class="comment">/* attachment */</span> GL_COLOR_ATTACHMENT0, <span class="comment">/* texture */</span> color, <span class="comment">/* mipmap level */</span> 0);</div>
<div class="line"></div>
<div class="line">    GLenum buffers[]= { GL_COLOR_ATTACHMENT0 };</div>
<div class="line">    glDrawBuffers(1, buffers);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// nettoyage</span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">render( )</div>
<div class="line">{</div>
<div class="line"><span class="comment">// passe 1, dessiner dans la texture color, attachee au framebuffer</span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer);</div>
<div class="line">    glViewport( ... );</div>
<div class="line">    glClear( ... );</div>
<div class="line"></div>
<div class="line">    glBindVertexArray( ... );</div>
<div class="line">    glUseProgram( ... );</div>
<div class="line">    glUniform( ... );</div>
<div class="line">    glDraw( ... );</div>
<div class="line"></div>
<div class="line"><span class="comment">// passe 2, utiliser la texture de la passe 1 et dessiner dans la fenetre </span></div>
<div class="line">    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);</div>
<div class="line">    glViewport( ... );</div>
<div class="line">    glClear( ... );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// mettre a jour les mipmaps de la texture</span></div>
<div class="line">    glBindTexture(GL_TEXTURE_2D, color);</div>
<div class="line">    glGenerateMipmap(GL_TEXTURE_2D);</div>
<div class="line"></div>
<div class="line">    glBindVertexArray( ... );</div>
<div class="line">    glUseProgram( ... );</div>
<div class="line">    glUniform( ... );</div>
<div class="line">    glDraw( ... );</div>
<div class="line">}</div>
</div><!-- fragment --><p>exemple complet dans cf <a class="el" href="tuto__framebuffer_8cpp.html">tuto_framebuffer.cpp</a>. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 27 2017 09:25:26 for gKit2 light by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
